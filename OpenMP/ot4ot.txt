Notebook Intel Core i7-3630QM

# threads/size		10			100			1000		10000		100000		1000000			10000000

1			 0.000062s	  0.000095s		0.00062s	  0.0059s	  0.04206s		0.4887s			5.03891s
2			 0.000173s	  0.000220s		0.00073s	  0.0051s	  0.04035s		0.4524s			4.31507s
4			 0.000241s	  0.000274s		0.00079s	  0.0048s	  0.03908s		0.4186s			4.17427s
8			 0.003157s	  0.003172s		0.00165s	  0.0113s	  0.03801s		0.4327s			3.92030s
16			 0.000693s    0.000696s     0.00158s      0.0057s     0.02347s      0.3386s         3.85402s        
32           0.000970s    0.000479s     0.00092s      0.0048s     0.02181s      0.3912s         3.96078s
64			 0.002371s    0.000972s     0.00140s      0.0078s     0.04597s      0.3773s         3.93914s
128          0.003142s    0.004503s     0.00357s      0.0037s     0.01848s      0.3983s         3.90383s



Основная часть:
Разработка параллельной версии программы для сортировки данных.
Сортировка массива целых чисел при помощи метода быстрой сортировки (Quick Sort).

1. Постановка задачи.
Перед нами поставлена задача отсортировать массив целых чисел по неубыванию при помощи алгоритма быстрой сортировки. Результатом выполнения программы является полностью отсортированный массив.

Требуется:
1. Реализовать сортировку массива целых чисел любого размера с помощью технологии параллельного программирования OpenMP.
2. Сравнить эффективность последовательного и параллельного алгоритмов.
3. Исследовать масштабируемость полученных программ и построить графики зависимости времени выполнения программ от числа используемых ядер (потоков) и объёма входных данных.

2. Описание алгоритма быстрой сортировки массива целых чисел.

2.1 Основа: быстрая сортировка.
Простейшая форма алгоритма быстрой сортировки имеет вид:

Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем O(n*log ⁡(n)) обменов при упорядочении n элементов; из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.

Общая идея алгоритма состоит в следующем:

    Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см.ниже).
    Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующие друг за другом: «меньшие опорного», «равные» и «большие».
    Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

2.2 Параллельный алгоритм.

